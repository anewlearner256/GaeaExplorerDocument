:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in GaaeExplorer's source tree.
.. DO NOT EDIT THIS FILE, but the HMACContext.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_HMACContext:

HMACContext
===========

**Inherits:** :ref:`Reference<class_Reference>` **<** :ref:`Object<class_Object>`

用来为一个使用密钥的信息创建 HMAC。

描述
----

HMACContext 类对于高级的 HMAC 用例非常有用，例如流式消息，因为它支持在一段时间内创建消息，而不是一次性提供。

::

    extends Node
    var ctx = HMACContext.new()
    
    func _ready():
        var key = "supersecret".to_utf8()
        var err = ctx.start(HashingContext.HASH_SHA256, key)
        assert(err == OK)
        var msg1 = "this is ".to_utf8()
        var msg2 = "vewy vewy secret".to_utf8()
        err = ctx.update(msg1)
        assert(err == OK)
        err = ctx.update(msg2)
        assert(err == OK)
        var hmac = ctx.finish()
        print(hmac.hex_encode())

而在 C# 中，我们可以使用下面的方法。

::

    using GaaeExplorer;
    using System;
    using System.Diagnostics;
    
    public class CryptoNode : Node
    {
        private HMACContext ctx = new HMACContext();
        public override void _Ready()
        {
            PoolByteArray key = String("supersecret").to_utf8();
            Error err = ctx.Start(HashingContext.HASH_SHA256, key);
            GD.Assert(err == OK);
            PoolByteArray msg1 = String("this is ").to_utf8();
            PoolByteArray msg2 = String("vewy vew secret").to_utf8();
            err = ctx.Update(msg1);
            GD.Assert(err == OK);
            err = ctx.Update(msg2);
            GD.Assert(err == OK);
            PoolByteArray hmac = ctx.Finish();
            GD.Print(hmac.HexEncode());
        }
    }

\ **注意：**\ 在 HTML5 导出中不可用。

方法
----

+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`PoolByteArray<class_PoolByteArray>` | :ref:`finish<class_HMACContext_method_finish>` **(** **)**                                                                                                      |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Error<enum_@GlobalScope_Error>`     | :ref:`start<class_HMACContext_method_start>` **(** :ref:`HashType<enum_HashingContext_HashType>` hash_type, :ref:`PoolByteArray<class_PoolByteArray>` key **)** |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Error<enum_@GlobalScope_Error>`     | :ref:`update<class_HMACContext_method_update>` **(** :ref:`PoolByteArray<class_PoolByteArray>` data **)**                                                       |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+

方法说明
--------

.. _class_HMACContext_method_finish:

- :ref:`PoolByteArray<class_PoolByteArray>` **finish** **(** **)**

返回生成的 HMAC。如果 HMAC 失败，将返回一个空的 :ref:`PoolByteArray<class_PoolByteArray>`\ 。

----

.. _class_HMACContext_method_start:

- :ref:`Error<enum_@GlobalScope_Error>` **start** **(** :ref:`HashType<enum_HashingContext_HashType>` hash_type, :ref:`PoolByteArray<class_PoolByteArray>` key **)**

初始化 HMACContext。在 :ref:`finish<class_HMACContext_method_finish>` 被调用之前，不能在同一个 HMACContext 上再次调用此方法。

----

.. _class_HMACContext_method_update:

- :ref:`Error<enum_@GlobalScope_Error>` **update** **(** :ref:`PoolByteArray<class_PoolByteArray>` data **)**

更新要进行 HMAC 的消息。在调用 :ref:`finish<class_HMACContext_method_finish>` 将 ``data`` 追加到消息中之前，可以多次调用，但在调用 :ref:`start<class_HMACContext_method_start>` 之前不能调用。

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
