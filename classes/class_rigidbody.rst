:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in GaaeExplorer's source tree.
.. DO NOT EDIT THIS FILE, but the RigidBody.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_RigidBody:

RigidBody
=========

**Inherits:** :ref:`PhysicsBody<class_PhysicsBody>` **<** :ref:`CollisionObject<class_CollisionObject>` **<** :ref:`Spatial<class_Spatial>` **<** :ref:`Node<class_Node>` **<** :ref:`Object<class_Object>`

**Inherited By:** :ref:`VehicleBody<class_VehicleBody>`

物理物体，其位置是通过 3D 空间中的物理模拟确定的。

描述
----

这是实现完整 3D 物理的节点。这意味着你是不直接控制刚体。而是，可以对其施加力，重力、冲力等，模拟物理将计算由此产生的运动、碰撞、弹跳、旋转等。

刚体有 4 种行为 :ref:`mode<class_RigidBody_property_mode>`\ ：刚体、静态、角色和运动。

\ **注意：**\ 不要每帧或非常频繁地改变刚体的位置。零星的更改将正常工作，但物理运行的粒度（固定 Hz）与通常的渲染（进程回调）不同，甚至可能在单独的线程中运行，因此从进程循环更改它可能会导致异常。如果需要直接影响物体的状态，使用\ :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>`\ ，可以直接访问物理状态。

如果你需要覆盖默认的物理行为，可以编写自定义的力积分函数。参阅\ :ref:`custom_integrator<class_RigidBody_property_custom_integrator>`\ 。

对于子弹物理（默认），质心是 RigidBody3D 中心。对于 GaaeExplorerPhysics，质心是 :ref:`CollisionShape<class_CollisionShape>` 中心的平均值。

教程
----

- :doc:`Physics introduction <../tutorials/physics/physics_introduction>`

- `3D Truck Town Demo <https://godotengine.org/asset-library/asset/524>`__

- `3D Physics Tests Demo <https://godotengine.org/asset-library/asset/675>`__

属性
----

+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`angular_damp<class_RigidBody_property_angular_damp>`                           | ``-1.0``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Vector3<class_Vector3>`                 | :ref:`angular_velocity<class_RigidBody_property_angular_velocity>`                   | ``Vector3( 0, 0, 0 )`` |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_x<class_RigidBody_property_axis_lock_angular_x>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_y<class_RigidBody_property_axis_lock_angular_y>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_z<class_RigidBody_property_axis_lock_angular_z>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_x<class_RigidBody_property_axis_lock_linear_x>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_y<class_RigidBody_property_axis_lock_linear_y>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_z<class_RigidBody_property_axis_lock_linear_z>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`bounce<class_RigidBody_property_bounce>`                                       |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`can_sleep<class_RigidBody_property_can_sleep>`                                 | ``true``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`                     | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`int<class_int>`                         | :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`                 | ``0``                  |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`continuous_cd<class_RigidBody_property_continuous_cd>`                         | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`custom_integrator<class_RigidBody_property_custom_integrator>`                 | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`friction<class_RigidBody_property_friction>`                                   |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`gravity_scale<class_RigidBody_property_gravity_scale>`                         | ``1.0``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`linear_damp<class_RigidBody_property_linear_damp>`                             | ``-1.0``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Vector3<class_Vector3>`                 | :ref:`linear_velocity<class_RigidBody_property_linear_velocity>`                     | ``Vector3( 0, 0, 0 )`` |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`mass<class_RigidBody_property_mass>`                                           | ``1.0``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Mode<enum_RigidBody_Mode>`              | :ref:`mode<class_RigidBody_property_mode>`                                           | ``0``                  |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`PhysicsMaterial<class_PhysicsMaterial>` | :ref:`physics_material_override<class_RigidBody_property_physics_material_override>` |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`sleeping<class_RigidBody_property_sleeping>`                                   | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`weight<class_RigidBody_property_weight>`                                       | ``9.8``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+

方法
----

+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>` **(** :ref:`PhysicsDirectBodyState<class_PhysicsDirectBodyState>` state **)** |virtual| |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_central_force<class_RigidBody_method_add_central_force>` **(** :ref:`Vector3<class_Vector3>` force **)**                                         |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_force<class_RigidBody_method_add_force>` **(** :ref:`Vector3<class_Vector3>` force, :ref:`Vector3<class_Vector3>` position **)**                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_torque<class_RigidBody_method_add_torque>` **(** :ref:`Vector3<class_Vector3>` torque **)**                                                      |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_central_impulse<class_RigidBody_method_apply_central_impulse>` **(** :ref:`Vector3<class_Vector3>` impulse **)**                               |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_impulse<class_RigidBody_method_apply_impulse>` **(** :ref:`Vector3<class_Vector3>` position, :ref:`Vector3<class_Vector3>` impulse **)**       |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_torque_impulse<class_RigidBody_method_apply_torque_impulse>` **(** :ref:`Vector3<class_Vector3>` impulse **)**                                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`bool<class_bool>`   | :ref:`get_axis_lock<class_RigidBody_method_get_axis_lock>` **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis **)** |const|                           |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Array<class_Array>` | :ref:`get_colliding_bodies<class_RigidBody_method_get_colliding_bodies>` **(** **)** |const|                                                               |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Basis<class_Basis>` | :ref:`get_inverse_inertia_tensor<class_RigidBody_method_get_inverse_inertia_tensor>` **(** **)**                                                           |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`set_axis_lock<class_RigidBody_method_set_axis_lock>` **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis, :ref:`bool<class_bool>` lock **)**     |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`set_axis_velocity<class_RigidBody_method_set_axis_velocity>` **(** :ref:`Vector3<class_Vector3>` axis_velocity **)**                                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+

信号
----

.. _class_RigidBody_signal_body_entered:

- **body_entered** **(** :ref:`Node<class_Node>` body **)**

当与另一个\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 发生碰撞时触发。需要将\ :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`\ 设置为\ ``true``\ ，并且将\ :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`\ 设置得足够高以检测所有的碰撞。如果\ :ref:`MeshLibrary<class_MeshLibrary>`\ 有碰撞\ :ref:`Shape<class_Shape>`\ ，\ :ref:`GridMap<class_GridMap>`\ 就会被检测到。

\ ``body``\ 的\ :ref:`Node<class_Node>`\ ，如果它存在于树中，则是其他\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的节点。

----

.. _class_RigidBody_signal_body_exited:

- **body_exited** **(** :ref:`Node<class_Node>` body **)**

当与另一个\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的碰撞结束时触发。需要将\ :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`\ 设置为\ ``true``\ ，并且将\ :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`\ 设置得足够高以检测到所有的碰撞。如果\ :ref:`MeshLibrary<class_MeshLibrary>`\ 有碰撞\ :ref:`Shape<class_Shape>`\ ，\ :ref:`GridMap<class_GridMap>`\ 就会被检测到。

\ ``body``\ 的\ :ref:`Node<class_Node>`\ ，如果它存在于树中，则是其他\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的节点。

----

.. _class_RigidBody_signal_body_shape_entered:

- **body_shape_entered** **(** :ref:`RID<class_RID>` body_rid, :ref:`Node<class_Node>` body, :ref:`int<class_int>` body_shape_index, :ref:`int<class_int>` local_shape_index **)**

当\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的一个形状\ :ref:`Shape<class_Shape>`\ 进入这个区域的一个形状\ :ref:`Shape<class_Shape>`\ 时发出的。需要将监控\ :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`\ 设置为\ ``true``\ ，且\ :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`\ 设置的足够高以检测所有碰撞。如果\ :ref:`MeshLibrary<class_MeshLibrary>`\ 有碰撞形状\ :ref:`Shape<class_Shape>`\ ，就会检测到\ :ref:`GridMap<class_GridMap>`\ 。

\ ``body_id``\ 由\ :ref:`PhysicsServer<class_PhysicsServer>`\ 使用的其他\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`MeshLibrary<class_MeshLibrary>`\ 的\ :ref:`CollisionObject<class_CollisionObject>`\ 的\ :ref:`RID<class_RID>`\ 。

\ ``body`` 其他\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的\ :ref:`Node<class_Node>`\ (如果它存在于树中)。

\ ``body_shape_index`` 由\ :ref:`PhysicsServer<class_PhysicsServer>`\ 使用的其他\ :ref:`PhysicsBody<class_PhysicsBody>`\ 或\ :ref:`GridMap<class_GridMap>`\ 的\ :ref:`Shape<class_Shape>`\ 的索引。用 ``body.shape_owner_get_owner(body_shape_index)``\ 获取 :ref:`CollisionShape<class_CollisionShape>` 节点。

\ ``local_shape`` 由\ :ref:`PhysicsServer<class_PhysicsServer>`\ 使用的这个刚体(RigidBody)的\ :ref:`Shape<class_Shape>`\ 的索引。用\ ``self.shape_owner_get_owner(local_shape_index)``\ 获取\ :ref:`CollisionShape<class_CollisionShape>`\ 节点。

\ **注意：**\ 当使用\ :ref:`ConcavePolygonShape<class_ConcavePolygonShape>`\ 时，对于子弹的物理运算无法识别形状索引。如果你需要形状指数，在使用\ :ref:`ConcavePolygonShape<class_ConcavePolygonShape>`\ 和对于子弹的物理运算时，不要使用多个\ :ref:`CollisionShape<class_CollisionShape>`\ 。

----

.. _class_RigidBody_signal_body_shape_exited:

- **body_shape_exited** **(** :ref:`RID<class_RID>` body_rid, :ref:`Node<class_Node>` body, :ref:`int<class_int>` body_shape_index, :ref:`int<class_int>` local_shape_index **)**

当此 RigidBody 的 :ref:`Shape<class_Shape>` 之一与另一个 :ref:`PhysicsBody<class_PhysicsBody>` 或 :ref:`GridMap<class_GridMap>` 的 :ref:`Shape<class_Shape>` 之间的碰撞结束时发出。需要将 :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` 设置为 ``true`` 并将 :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` 设置为足够高以检测所有碰撞。如果 :ref:`MeshLibrary<class_MeshLibrary>` 有碰撞 :ref:`Shape<class_Shape>`\ ，就会检测到 :ref:`GridMap<class_GridMap>`\ 。

\ ``body_rid`` :ref:`PhysicsServer<class_PhysicsServer>` 使用的其他 :ref:`PhysicsBody<class_PhysicsBody>` 或 :ref:`MeshLibrary<class_MeshLibrary>` 的 :ref:`CollisionObject<class_CollisionObject>` 的 :ref:`RID<class_RID>`\ 。如果网格具有 :ref:`Shape<class_Shape>`\ ，则检测到 :ref:`GridMap<class_GridMap>`\ 。

\ ``body`` 其他 :ref:`PhysicsBody<class_PhysicsBody>` 或 :ref:`GridMap<class_GridMap>` 的 :ref:`Node<class_Node>`\ ，如果它存在于树中。

\ ``body_shape_index`` :ref:`PhysicsServer<class_PhysicsServer>` 使用的其他 :ref:`PhysicsBody<class_PhysicsBody>` 或 :ref:`GridMap<class_GridMap>` 的 :ref:`Shape<class_Shape>` 的索引。使用 ``body.shape_owner_get_owner(body_shape_index)`` 来获取 :ref:`CollisionShape<class_CollisionShape>` 节点。

\ ``local_shape_index`` :ref:`PhysicsServer<class_PhysicsServer>` 使用的这个 RigidBody 的 :ref:`Shape<class_Shape>` 的索引。使用 ``self.shape_owner_get_owner(local_shape_index)`` 获取 :ref:`CollisionShape<class_CollisionShape>` 节点。

\ **注意：**\ 使用\ :ref:`ConcavePolygonShape<class_ConcavePolygonShape>`\ 时，对于子弹的物理运算无法识别形状索引。如果需要形状索引，请不要在使用带有对于子弹的物理运算的 :ref:`ConcavePolygonShape<class_ConcavePolygonShape>` 时使用多个 :ref:`CollisionShape<class_CollisionShape>`\ 。

----

.. _class_RigidBody_signal_sleeping_state_changed:

- **sleeping_state_changed** **(** **)**

当物理引擎改变物体的睡眠状态时发出。

\ **注意：**\ 改变\ :ref:`sleeping<class_RigidBody_property_sleeping>`\ 的值不会触发这个信号。只有当物理引擎改变了睡眠状态或者使用了\ ``emit_signal("sleeping_state_changed")``\ 时，它才会被发出。

枚举
----

.. _enum_RigidBody_Mode:

.. _class_RigidBody_constant_MODE_RIGID:

.. _class_RigidBody_constant_MODE_STATIC:

.. _class_RigidBody_constant_MODE_CHARACTER:

.. _class_RigidBody_constant_MODE_KINEMATIC:

enum **Mode**:

- **MODE_RIGID** = **0** --- 刚体模式。这是一个刚体的 "自然 "状态。它受到力的影响，可以移动、旋转，并受到用户代码的影响。

- **MODE_STATIC** = **1** --- 静止模式。实体的行为就像一个\ :ref:`StaticBody<class_StaticBody>`\ ，只能通过用户代码移动。

- **MODE_CHARACTER** = **2** --- 角色模式。这与刚体的行为类似，但不能旋转。

- **MODE_KINEMATIC** = **3** --- 运动体模式。这个实体的行为就像一个\ :ref:`KinematicBody<class_KinematicBody>`\ ，只能通过用户代码来移动。

属性说明
--------

.. _class_RigidBody_property_angular_damp:

- :ref:`float<class_float>` **angular_damp**

+-----------+-------------------------+
| *Default* | ``-1.0``                |
+-----------+-------------------------+
| *Setter*  | set_angular_damp(value) |
+-----------+-------------------------+
| *Getter*  | get_angular_damp()      |
+-----------+-------------------------+

阻尼刚体的旋转力。

关于阻尼的更多细节，请参阅\ :ref:`ProjectSettings.physics/3d/default_angular_damp<class_ProjectSettings_property_physics/3d/default_angular_damp>`\ 。

----

.. _class_RigidBody_property_angular_velocity:

- :ref:`Vector3<class_Vector3>` **angular_velocity**

+-----------+-----------------------------+
| *Default* | ``Vector3( 0, 0, 0 )``      |
+-----------+-----------------------------+
| *Setter*  | set_angular_velocity(value) |
+-----------+-----------------------------+
| *Getter*  | get_angular_velocity()      |
+-----------+-----------------------------+

物体的旋转速度，使用轴-角格式。向量的大小表示旋转率，单位为\ *弧度*\ 每秒。

----

.. _class_RigidBody_property_axis_lock_angular_x:

- :ref:`bool<class_bool>` **axis_lock_angular_x**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在X轴上的旋转。

----

.. _class_RigidBody_property_axis_lock_angular_y:

- :ref:`bool<class_bool>` **axis_lock_angular_y**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在Y轴上的旋转。

----

.. _class_RigidBody_property_axis_lock_angular_z:

- :ref:`bool<class_bool>` **axis_lock_angular_z**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在Z轴上的旋转。

----

.. _class_RigidBody_property_axis_lock_linear_x:

- :ref:`bool<class_bool>` **axis_lock_linear_x**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在X轴上的移动。

----

.. _class_RigidBody_property_axis_lock_linear_y:

- :ref:`bool<class_bool>` **axis_lock_linear_y**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在Y轴上的移动。

----

.. _class_RigidBody_property_axis_lock_linear_z:

- :ref:`bool<class_bool>` **axis_lock_linear_z**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

锁定实体在Z轴上的移动。

----

.. _class_RigidBody_property_bounce:

- :ref:`float<class_float>` **bounce**

+----------+-------------------+
| *Setter* | set_bounce(value) |
+----------+-------------------+
| *Getter* | get_bounce()      |
+----------+-------------------+

实体的弹性。值范围从\ ``0``\ （无弹跳）到\ ``1``\ （完全弹跳）。

已被废弃，请通过\ :ref:`physics_material_override<class_RigidBody_property_physics_material_override>`\ 使用\ :ref:`PhysicsMaterial.bounce<class_PhysicsMaterial_property_bounce>`\ 代替。

----

.. _class_RigidBody_property_can_sleep:

- :ref:`bool<class_bool>` **can_sleep**

+-----------+----------------------+
| *Default* | ``true``             |
+-----------+----------------------+
| *Setter*  | set_can_sleep(value) |
+-----------+----------------------+
| *Getter*  | is_able_to_sleep()   |
+-----------+----------------------+

如果\ ``true``\ ，实体可以在没有运动的情况下进入睡眠模式。见\ :ref:`sleeping<class_RigidBody_property_sleeping>`\ 。

\ **注意：** RigidBody3D 的模式\ :ref:`mode<class_RigidBody_property_mode>` 为常量\ :ref:`MODE_CHARACTER<class_RigidBody_constant_MODE_CHARACTER>` 时不会自动进入休眠模式。仍然可以通过将其 :ref:`sleeping<class_RigidBody_property_sleeping>` 属性设置为 ``true`` 来手动使其进入休眠状态。

----

.. _class_RigidBody_property_contact_monitor:

- :ref:`bool<class_bool>` **contact_monitor**

+-----------+------------------------------+
| *Default* | ``false``                    |
+-----------+------------------------------+
| *Setter*  | set_contact_monitor(value)   |
+-----------+------------------------------+
| *Getter*  | is_contact_monitor_enabled() |
+-----------+------------------------------+

如果\ ``true``\ ，当RigidBody与另一个RigidBody碰撞时会发出信号。参阅\ :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`\ 。

----

.. _class_RigidBody_property_contacts_reported:

- :ref:`int<class_int>` **contacts_reported**

+-----------+----------------------------------+
| *Default* | ``0``                            |
+-----------+----------------------------------+
| *Setter*  | set_max_contacts_reported(value) |
+-----------+----------------------------------+
| *Getter*  | get_max_contacts_reported()      |
+-----------+----------------------------------+

将被记录的最大接触次数。需要将 :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` 设置为 ``true``\ 。

\ **注：**\ 接触次数与碰撞次数不同。平行边之间的碰撞将导致两个接触（每端一个），平行面之间的碰撞将导致四个接触（每个角一个）。

----

.. _class_RigidBody_property_continuous_cd:

- :ref:`bool<class_bool>` **continuous_cd**

+-----------+-----------------------------------------------+
| *Default* | ``false``                                     |
+-----------+-----------------------------------------------+
| *Setter*  | set_use_continuous_collision_detection(value) |
+-----------+-----------------------------------------------+
| *Getter*  | is_using_continuous_collision_detection()     |
+-----------+-----------------------------------------------+

如果 ``true``\ ，则使用连续碰撞检测。

连续碰撞检测尝试预测一个移动的物体会在哪里碰撞，而不是移动它并在它发生碰撞时纠正它的运动。连续碰撞检测更精确，并且错过了较小的、快速移动的物体的撞击。不使用连续碰撞检测的计算速度更快，但可能会错过小的、快速移动的物体。

----

.. _class_RigidBody_property_custom_integrator:

- :ref:`bool<class_bool>` **custom_integrator**

+-----------+----------------------------------+
| *Default* | ``false``                        |
+-----------+----------------------------------+
| *Setter*  | set_use_custom_integrator(value) |
+-----------+----------------------------------+
| *Getter*  | is_using_custom_integrator()     |
+-----------+----------------------------------+

如果 ``true``\ ，则该物体的内力积分将被禁用（如重力或空气摩擦）。除了碰撞响应之外，物体将仅根据 :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>` 函数确定的方式移动（如果已定义）。

----

.. _class_RigidBody_property_friction:

- :ref:`float<class_float>` **friction**

+----------+---------------------+
| *Setter* | set_friction(value) |
+----------+---------------------+
| *Getter* | get_friction()      |
+----------+---------------------+

实体的摩擦力，从0（无摩擦）到1（最大摩擦）。

已经废弃，请通过 :ref:`physics_material_override<class_RigidBody_property_physics_material_override>` 使用 :ref:`PhysicsMaterial.friction<class_PhysicsMaterial_property_friction>` 代替。

----

.. _class_RigidBody_property_gravity_scale:

- :ref:`float<class_float>` **gravity_scale**

+-----------+--------------------------+
| *Default* | ``1.0``                  |
+-----------+--------------------------+
| *Setter*  | set_gravity_scale(value) |
+-----------+--------------------------+
| *Getter*  | get_gravity_scale()      |
+-----------+--------------------------+

这与在\ **项目 > 项目设置 > Physics > 3d** 中找到的全局 3D 重力设置相乘，产生 RigidBody 的重力。例如，1 的值将是正常的重力，2 将应用双倍的重力，0.5 将对这个物体应用一半的重力。

----

.. _class_RigidBody_property_linear_damp:

- :ref:`float<class_float>` **linear_damp**

+-----------+------------------------+
| *Default* | ``-1.0``               |
+-----------+------------------------+
| *Setter*  | set_linear_damp(value) |
+-----------+------------------------+
| *Getter*  | get_linear_damp()      |
+-----------+------------------------+

实体的线性阻尼。不能小于-1.0。如果这个值与-1.0不同，任何从世界或区域派生的线性阻尼将被覆盖。

关于阻尼的更多细节，请参阅\ :ref:`ProjectSettings.physics/3d/default_linear_damp<class_ProjectSettings_property_physics/3d/default_linear_damp>`\ 。

----

.. _class_RigidBody_property_linear_velocity:

- :ref:`Vector3<class_Vector3>` **linear_velocity**

+-----------+----------------------------+
| *Default* | ``Vector3( 0, 0, 0 )``     |
+-----------+----------------------------+
| *Setter*  | set_linear_velocity(value) |
+-----------+----------------------------+
| *Getter*  | get_linear_velocity()      |
+-----------+----------------------------+

物体的线速度，单位为单位每秒。可以偶尔使用，但是\ **不要每一帧都设置它**\ ，因为物理可能在另一个线程中运行，并且以不同的间隔。使用 :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>` 作为你的进程循环，以精确控制物体状态。

----

.. _class_RigidBody_property_mass:

- :ref:`float<class_float>` **mass**

+-----------+-----------------+
| *Default* | ``1.0``         |
+-----------+-----------------+
| *Setter*  | set_mass(value) |
+-----------+-----------------+
| *Getter*  | get_mass()      |
+-----------+-----------------+

实体的质量。

----

.. _class_RigidBody_property_mode:

- :ref:`Mode<enum_RigidBody_Mode>` **mode**

+-----------+-----------------+
| *Default* | ``0``           |
+-----------+-----------------+
| *Setter*  | set_mode(value) |
+-----------+-----------------+
| *Getter*  | get_mode()      |
+-----------+-----------------+

物体的模式。可能的值见\ :ref:`Mode<enum_RigidBody_Mode>`\ 。

----

.. _class_RigidBody_property_physics_material_override:

- :ref:`PhysicsMaterial<class_PhysicsMaterial>` **physics_material_override**

+----------+--------------------------------------+
| *Setter* | set_physics_material_override(value) |
+----------+--------------------------------------+
| *Getter* | get_physics_material_override()      |
+----------+--------------------------------------+

物体的物理材质。

如果为该属性指定了一种材质，则将使用该材质代替任何其他物理材质，例如继承的材质。

----

.. _class_RigidBody_property_sleeping:

- :ref:`bool<class_bool>` **sleeping**

+-----------+---------------------+
| *Default* | ``false``           |
+-----------+---------------------+
| *Setter*  | set_sleeping(value) |
+-----------+---------------------+
| *Getter*  | is_sleeping()       |
+-----------+---------------------+

如果 ``true``\ ，物体不会移动并且不会计算力，直到被另一个物体唤醒，例如碰撞，或使用 :ref:`apply_impulse<class_RigidBody_method_apply_impulse>` 或 :ref:`add_force<class_RigidBody_method_add_force>` 方法。

----

.. _class_RigidBody_property_weight:

- :ref:`float<class_float>` **weight**

+-----------+-------------------+
| *Default* | ``9.8``           |
+-----------+-------------------+
| *Setter*  | set_weight(value) |
+-----------+-------------------+
| *Getter*  | get_weight()      |
+-----------+-------------------+

实体的重量基于其质量和全局 3D 重力。全局值在\ **项目 > 项目设置 > Physics > 3D** 中设置。

方法说明
--------

.. _class_RigidBody_method__integrate_forces:

- void **_integrate_forces** **(** :ref:`PhysicsDirectBodyState<class_PhysicsDirectBodyState>` state **)** |virtual|

在物理处理过程中被调用，允许你读取并安全地修改对象的模拟状态。默认情况下，它是在通常的物理行为之外工作的，但是\ :ref:`custom_integrator<class_RigidBody_property_custom_integrator>`\ 属性允许你禁用默认行为，为一个物体施加完全自定义的合力。

----

.. _class_RigidBody_method_add_central_force:

- void **add_central_force** **(** :ref:`Vector3<class_Vector3>` force **)**

在不影响旋转的情况下添加恒定的方向力（即加速度）。

这相当于 ``add_force(force, Vector3(0,0,0))``\ 。

----

.. _class_RigidBody_method_add_force:

- void **add_force** **(** :ref:`Vector3<class_Vector3>` force, :ref:`Vector3<class_Vector3>` position **)**

添加一个恒定的方向力（即加速度）。

位置使用全局坐标系的旋转，但以物体的原点为中心。

----

.. _class_RigidBody_method_add_torque:

- void **add_torque** **(** :ref:`Vector3<class_Vector3>` torque **)**

在不影响位置的情况下添加恒定的旋转力。

----

.. _class_RigidBody_method_apply_central_impulse:

- void **apply_central_impulse** **(** :ref:`Vector3<class_Vector3>` impulse **)**

施加单一方向的冲量而不影响旋转。

这等价于\ ``apply_impulse(Vector3(0,0,0), impulse)``\ 。

----

.. _class_RigidBody_method_apply_impulse:

- void **apply_impulse** **(** :ref:`Vector3<class_Vector3>` position, :ref:`Vector3<class_Vector3>` impulse **)**

对物体施加一个有向的冲量。冲量是与时间无关的! 在每一帧中施加一个冲量将产生一个与帧率相关的力。出于这个原因，它应该只在模拟一次性影响时使用。该位置使用全局坐标系的旋转，但以物体的原点为中心。

----

.. _class_RigidBody_method_apply_torque_impulse:

- void **apply_torque_impulse** **(** :ref:`Vector3<class_Vector3>` impulse **)**

施加一个冲量矩，它将受到物体质量和形状的影响。这将使物体围绕所传递的\ ``impulse``\ 向量进行旋转。

----

.. _class_RigidBody_method_get_axis_lock:

- :ref:`bool<class_bool>` **get_axis_lock** **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis **)** |const|

如果指定的线性或旋转轴被锁定，则返回 ``true``\ 。

----

.. _class_RigidBody_method_get_colliding_bodies:

- :ref:`Array<class_Array>` **get_colliding_bodies** **(** **)** |const|

返回一个与此碰撞的物体的列表。要求\ :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`\ 设置为\ ``true``\ ，\ :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`\ 设置得足够高，以检测所有碰撞。

\ **注意：** 在移动物体后，这个测试的结果不是立即的。为了性能，碰撞列表每帧在物理运算之前更新一次。可以考虑使用信号来代替。

----

.. _class_RigidBody_method_get_inverse_inertia_tensor:

- :ref:`Basis<class_Basis>` **get_inverse_inertia_tensor** **(** **)**

返回逆惯性张力基矩阵(Basis)。这用于计算由施加到刚体的扭矩产生的角加速度。

----

.. _class_RigidBody_method_set_axis_lock:

- void **set_axis_lock** **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis, :ref:`bool<class_bool>` lock **)**

锁定指定的线性或旋转轴。

----

.. _class_RigidBody_method_set_axis_velocity:

- void **set_axis_velocity** **(** :ref:`Vector3<class_Vector3>` axis_velocity **)**

设置轴速度。给定向量轴上的速度将被设置为给定向量长度。这对跳跃行为很有用。

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
