:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in GaaeExplorer's source tree.
.. DO NOT EDIT THIS FILE, but the UDPServer.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_UDPServer:

UDPServer
=========

**Inherits:** :ref:`Reference<class_Reference>` **<** :ref:`Object<class_Object>`

用于实现UDP服务的辅助类。

描述
----

一个简单的服务器，它打开一个 UDP 套接字，并在收到新的数据包时，返回连接的 :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ 。请参阅 :ref:`PacketPeerUDP.connect_to_host<class_PacketPeerUDP_method_connect_to_host>`\ 。

启动服务器后（\ :ref:`listen<class_UDPServer_method_listen>`\ ），你将需要定期 :ref:`poll<class_UDPServer_method_poll>` 它（例如在 :ref:`Node._process<class_Node_method__process>` 内），才会处理新的数据包、将它们传递给适当的 :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ 、接受新连接。

下面是一个关于如何使用它的小例子。

::

    # server.gd
    extends Node
    
    var server := UDPServer.new()
    var peers = []
    
    func _ready():
        server.listen(4242)
    
    func _process(delta):
        server.poll() # 重要！
        if server.is_connection_available():
            var peer : PacketPeerUDP = server.take_connection()
            var pkt = peer.get_packet()
            print("接受到 peer：%s:%s" % [peer.get_packet_ip(), peer.get_packet_port()])
            print("收到数据：%s" % [pkt.get_string_from_utf8()])
            # 发出回复，这样对方就能知道我们收到了消息。
            peer.put_packet(pkt)
            # 保持引用，这样就可以不断与远程 peer 联系。
            peers.append(peer)
    
        for i in range(0, peers.size()):
            pass # 与已连接的 peer 进行交互
    

::

    # client.gd
    extends Node
    
    var udp := PacketPeerUDP.new()
    var connected = false
    
    func _ready():
        udp.connect_to_host("127.0.0.1", 4242)
    
    func _process(delta):
        if !connected:
            # 尝试联系服务器
            udp.put_packet("答案是……42！".to_utf8())
        if udp.get_available_packet_count() > 0:
            print("已连接：%s" % udp.get_packet().get_string_from_utf8())
            connected = true

属性
----

+-----------------------+----------------------------------------------------------------------------------+--------+
| :ref:`int<class_int>` | :ref:`max_pending_connections<class_UDPServer_property_max_pending_connections>` | ``16`` |
+-----------------------+----------------------------------------------------------------------------------+--------+

方法
----

+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| :ref:`bool<class_bool>`                   | :ref:`is_connection_available<class_UDPServer_method_is_connection_available>` **(** **)** |const|                                |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| :ref:`bool<class_bool>`                   | :ref:`is_listening<class_UDPServer_method_is_listening>` **(** **)** |const|                                                      |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Error<enum_@GlobalScope_Error>`     | :ref:`listen<class_UDPServer_method_listen>` **(** :ref:`int<class_int>` port, :ref:`String<class_String>` bind_address="*" **)** |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Error<enum_@GlobalScope_Error>`     | :ref:`poll<class_UDPServer_method_poll>` **(** **)**                                                                              |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| void                                      | :ref:`stop<class_UDPServer_method_stop>` **(** **)**                                                                              |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| :ref:`PacketPeerUDP<class_PacketPeerUDP>` | :ref:`take_connection<class_UDPServer_method_take_connection>` **(** **)**                                                        |
+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------+

属性说明
--------

.. _class_UDPServer_property_max_pending_connections:

- :ref:`int<class_int>` **max_pending_connections**

+-----------+------------------------------------+
| *Default* | ``16``                             |
+-----------+------------------------------------+
| *Setter*  | set_max_pending_connections(value) |
+-----------+------------------------------------+
| *Getter*  | get_max_pending_connections()      |
+-----------+------------------------------------+

定义最大的待定连接数，在\ :ref:`poll<class_UDPServer_method_poll>`\ 期间，任何超过该值的新待定连接将被自动放弃。把这个值设置为\ ``0``\ 可以有效地防止任何新的待定连接被接受，例如，当你的所有玩家都连接时。

方法说明
--------

.. _class_UDPServer_method_is_connection_available:

- :ref:`bool<class_bool>` **is_connection_available** **(** **)** |const|

如果在套接字中收到一个具有新地址及端口组合的数据包，则返回\ ``true``\ 。

----

.. _class_UDPServer_method_is_listening:

- :ref:`bool<class_bool>` **is_listening** **(** **)** |const|

如果套接字是打开的，并且在监听端口，则返回\ ``true``\ 。

----

.. _class_UDPServer_method_listen:

- :ref:`Error<enum_@GlobalScope_Error>` **listen** **(** :ref:`int<class_int>` port, :ref:`String<class_String>` bind_address="*" **)**

通过在给定的端口上打开一个UDP套接字来启动服务。你可以选择指定一个\ ``bind_address``\ ，只监听发送到该地址的数据包。参阅\ :ref:`PacketPeerUDP.listen<class_PacketPeerUDP_method_listen>`\ 。

----

.. _class_UDPServer_method_poll:

- :ref:`Error<enum_@GlobalScope_Error>` **poll** **(** **)**

定期调用这个方法，例如在\ :ref:`Node._process<class_Node_method__process>`\ 里面，来处理新数据包。来自已知地址及端口对的数据包，将被传递到相应的\ :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ，任何从未知地址及端口对收到的数据包将被添加为一个待定连接，参阅\ :ref:`is_connection_available<class_UDPServer_method_is_connection_available>`, :ref:`take_connection<class_UDPServer_method_take_connection>`\ 。待定连接的最大数量通过\ :ref:`max_pending_connections<class_UDPServer_property_max_pending_connections>`\ 定义。

----

.. _class_UDPServer_method_stop:

- void **stop** **(** **)**

停止服务，如果UDP套接字是打开的，就关闭它。将关闭所有通过\ :ref:`take_connection<class_UDPServer_method_take_connection>`\ 接受连接的\ :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ，注，不会通知远程对等体。

----

.. _class_UDPServer_method_take_connection:

- :ref:`PacketPeerUDP<class_PacketPeerUDP>` **take_connection** **(** **)**

返回第一个挂起的连接，注，连接到适当的地址及端口。如果没有新的连接可用，将返回\ ``null``\ 。参阅\ :ref:`is_connection_available<class_UDPServer_method_is_connection_available>`, :ref:`PacketPeerUDP.connect_to_host<class_PacketPeerUDP_method_connect_to_host>`\ 。

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
